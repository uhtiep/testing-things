<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Forsaken Generator Puzzle</title>
  <style>
    body {
      background: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding-top: 40px;
    }
    #getBtn {
      padding: 12px 24px;
      font-size: 18px;
      background: #22cc88;
      border: none;
      border-radius: 8px;
      cursor: pointer;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(6, 60px);
      grid-gap: 4px;
      justify-content: center;
      margin: 30px auto;
      width: max-content;
    }
    .cell {
      width: 60px;
      height: 60px;
      background: #333;
      border-radius: 8px;
      position: relative;
      cursor: pointer;
    }
    .dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 2;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <button id="getBtn">Get New Generator</button>
  <div id="gridWrapper" style="position:relative;" class="hidden">
    <canvas id="canvas" width="384" height="384"></canvas>
    <div id="grid"></div>
  </div>
  <audio id="completeSound" src="rblx-complete.mp3"></audio>

  <script>
    const getBtn = document.getElementById('getBtn');
    const gridWrapper = document.getElementById('gridWrapper');
    const gridEl = document.getElementById('grid');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const sound = document.getElementById('completeSound');

    const gridSize = 6;
    const totalPuzzles = 4;
    let activePuzzle = 0;
    let grid = [];
    let paths = {};
    let dotPairs = [];
    let currentColor = null;
    let drawing = false;
    let pathCoords = [];
    const colors = ['red', 'lime', 'yellow', 'cyan', 'orange', 'violet'];

    function createGrid() {
      grid = [];
      paths = {};
      dotPairs = [];
      gridEl.innerHTML = '';
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let used = Array(gridSize * gridSize).fill(false);
      let usedColors = [];

      for (let i = 0; i < 4; i++) {
        let color = colors[i % colors.length];
        usedColors.push(color);
        let pos1, pos2;
        do {
          pos1 = Math.floor(Math.random() * gridSize * gridSize);
        } while (used[pos1]);
        used[pos1] = true;
        do {
          pos2 = Math.floor(Math.random() * gridSize * gridSize);
        } while (used[pos2] || pos2 === pos1);
        used[pos2] = true;
        dotPairs.push({ color, indexes: [pos1, pos2] });
        paths[color] = [];
      }

      for (let i = 0; i < gridSize * gridSize; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        gridEl.appendChild(cell);
        grid.push(cell);
      }

      for (const pair of dotPairs) {
        for (let idx of pair.indexes) {
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = pair.color;
          grid[idx].appendChild(dot);
        }
      }
    }

    function getCoords(index) {
      const row = Math.floor(index / gridSize);
      const col = index % gridSize;
      return [col * 64 + 32, row * 64 + 32];
    }

    function handleMouseDown(e) {
      if (e.target.classList.contains('dot')) {
        const parent = e.target.parentElement;
        const index = parseInt(parent.dataset.index);
        currentColor = e.target.style.background;
        drawing = true;
        pathCoords = [index];
        drawPaths();
      }
    }

    function handleMouseMove(e) {
      if (!drawing || currentColor === null) return;
      const rect = gridEl.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const col = Math.floor(x / 64);
      const row = Math.floor(y / 64);
      const idx = row * gridSize + col;
      if (idx >= 0 && idx < gridSize * gridSize && !pathCoords.includes(idx)) {
        pathCoords.push(idx);
        drawPaths();
      }
    }

    function handleMouseUp() {
      if (drawing && currentColor !== null) {
        paths[currentColor] = [...pathCoords];
        drawing = false;
        pathCoords = [];
        currentColor = null;
        drawPaths();
        checkCompletion();
      }
    }

    function drawPaths() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let color in paths) {
        const path = paths[color];
        if (path.length < 2) continue;
        ctx.strokeStyle = color;
        ctx.lineWidth = 8;
        ctx.beginPath();
        const [x0, y0] = getCoords(path[0]);
        ctx.moveTo(x0, y0);
        for (let i = 1; i < path.length; i++) {
          const [x, y] = getCoords(path[i]);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      // draw current in-progress path
      if (drawing && pathCoords.length > 1) {
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = 8;
        ctx.beginPath();
        const [x0, y0] = getCoords(pathCoords[0]);
        ctx.moveTo(x0, y0);
        for (let i = 1; i < pathCoords.length; i++) {
          const [x, y] = getCoords(pathCoords[i]);
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
    }

    function checkCompletion() {
      for (let { color, indexes } of dotPairs) {
        const path = paths[color];
        if (!path || path.length < 2) return;
        if (!(path[0] === indexes[0] && path[path.length - 1] === indexes[1]) &&
            !(path[0] === indexes[1] && path[path.length - 1] === indexes[0])) {
          return;
        }
      }

      sound.play();
      activePuzzle++;
      if (activePuzzle < totalPuzzles) {
        setTimeout(() => {
          createGrid();
        }, 700);
      } else {
        setTimeout(() => {
          gridWrapper.classList.add('hidden');
          getBtn.classList.remove('hidden');
        }, 700);
      }
    }

    getBtn.addEventListener('click', () => {
      activePuzzle = 0;
      getBtn.classList.add('hidden');
      gridWrapper.classList.remove('hidden');
      createGrid();
    });

    gridEl.addEventListener('mousedown', handleMouseDown);
    gridEl.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  </script>
</body>
</html>
