<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glitch World</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    canvas {
      display: block;
      background-color: #000;
      margin: 0 auto;
    }
    #score {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 24px;
      color: white;
    }
  </style>
</head>
<body>

  <canvas id="gameCanvas"></canvas>
  <div id="score">Score: 0</div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const WIDTH = window.innerWidth;
    const HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Player setup
    const player = {
      x: WIDTH / 2,
      y: HEIGHT / 2,
      width: 40,
      height: 40,
      speed: 5,
      color: "cyan",
      health: 3,
      dashing: false,
      dashCooldown: 0
    };

    // Glitch effects and variables
    let glitchTime = 0;
    let glitchMode = false;
    let score = 0;
    let gameOver = false;

    // Enemies and key tracking
    const enemies = [];
    const bullets = [];
    const keys = { left: false, right: false, up: false, down: false, shoot: false };

    // Event listeners for player movement
    document.addEventListener("keydown", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = true;
      if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = true;
      if (e.code === "ArrowUp" || e.code === "KeyW") keys.up = true;
      if (e.code === "ArrowDown" || e.code === "KeyS") keys.down = true;
      if (e.code === "Space") keys.shoot = true;
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "KeyA") keys.left = false;
      if (e.code === "ArrowRight" || e.code === "KeyD") keys.right = false;
      if (e.code === "ArrowUp" || e.code === "KeyW") keys.up = false;
      if (e.code === "ArrowDown" || e.code === "KeyS") keys.down = false;
      if (e.code === "Space") keys.shoot = false;
    });

    // Player movement
    function movePlayer() {
      if (keys.left && player.x > 0) player.x -= player.speed;
      if (keys.right && player.x < WIDTH - player.width) player.x += player.speed;
      if (keys.up && player.y > 0) player.y -= player.speed;
      if (keys.down && player.y < HEIGHT - player.height) player.y += player.speed;
    }

    // Glitch effect handling
    function applyGlitchEffects() {
      if (glitchMode) {
        player.x += Math.random() * 5 - 2;  // Slight random player movement
        player.y += Math.random() * 5 - 2;

        if (Math.random() < 0.02) {
          // Random teleportation with lower frequency
          player.x = Math.random() * WIDTH;
          player.y = Math.random() * HEIGHT;
        }

        if (Math.random() < 0.005) {
          // Random control inversion with very low frequency
          player.speed = Math.random() < 0.5 ? 5 : -5;
        }
      }
    }

    // Create enemies periodically
    function createEnemies() {
      if (Math.random() < 0.02 && !gameOver) {  // Lower spawn frequency
        enemies.push({
          x: Math.random() * WIDTH,
          y: Math.random() * HEIGHT,
          width: 40,
          height: 40,
          color: "red",
          speed: 3
        });
      }
    }

    // Update and render enemies
    function updateEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        enemy.x += Math.cos(angle) * enemy.speed;
        enemy.y += Math.sin(angle) * enemy.speed;

        // Draw enemy
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }
    }

    // Handle shooting (basic bullet functionality)
    function shoot() {
      if (keys.shoot) {
        bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 10,
          speed: 7
        });
      }
    }

    // Update and render bullets
    function updateBullets() {
      for (let i = 0; i < bullets.length; i++) {
        const bullet = bullets[i];
        bullet.y -= bullet.speed; // Move bullet upwards
        ctx.fillStyle = "white";
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);

        // Collision check with enemies
        for (let j = 0; j < enemies.length; j++) {
          const enemy = enemies[j];
          if (isCollision(bullet, enemy)) {
            enemies.splice(j, 1);  // Remove enemy on hit
            bullets.splice(i, 1);  // Remove bullet on hit
            score++;  // Increase score
            break;
          }
        }
      }
    }

    // Collision check
    function isCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Game logic and rendering
    function update() {
      if (gameOver) return;

      movePlayer();
      applyGlitchEffects();
      createEnemies();
      shoot();
      updateEnemies();
      updateBullets();

      ctx.clearRect(0, 0, WIDTH, HEIGHT);

      // Draw player
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Draw score and health
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 20, 30);
      ctx.fillText("Health: " + player.health, 20, 60);

      // Handle game over
      if (player.health <= 0) {
        gameOver = true;
        ctx.fillText("GAME OVER", WIDTH / 2 - 70, HEIGHT / 2);
      }

      requestAnimationFrame(update);
    }

    // Start the game
    update();

  </script>

</body>
</html>
